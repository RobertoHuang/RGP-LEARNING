# NIO

> 程序员热衷于调试代码，`I/O`性能的调试往往被摆在第二位甚至完全忽略。殊不知在`I/O`性能上小小的投入就可换来可观的回报，想来实在令人惋惜 - 《`JAVA NIO`》

## I/O概念

### 缓冲区操作

> 缓冲区以及缓冲区如何工作是所有`I/O`的基础。所谓输入/输出讲的无非就是把数据移进或移出缓冲区
>
> **数据从外部磁盘向运行中的进程的内存区域移动的过程**:进程使用`read()`系统调用要求其缓冲区被填满，内核随即向磁盘控制硬件发出指令，要求其从磁盘读取数据。磁盘控制器把数据写入内核内存缓冲区(这一步通过`DMA`完成，无需主`CPU`协助)，一旦磁盘控制器把缓冲区装满内核即把数据从内核空间的临时缓冲区拷贝到进程`read()`调用时指定的缓冲区。示意图如下

![IO缓冲区操作简图](https://raw.githubusercontent.com/RobertoHuang/RGP-LEARNING/master/NIO/images/IO%E7%BC%93%E5%86%B2%E5%8C%BA%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE.png)

当进程请求I/O操作的时候它执行一个系统调用将控制权移交给内核，`C/C++`程序员所熟知的底层方法`open( )、 read( )、write( )、close( )`要做的无非就是建立和执行适当的系统调用。当内核以这种方式被调用它随即采取任何必要步骤找到进程所需数据，并把数据传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里了，如果是这样该数据只需简单地拷贝出来即可，如果数据不在内核空间，则进程被挂起，内核着手把数据读进内存。【所有`I/O`都直接或间接通过内核空间】

- `JVM`是常规进程，驻守于用户控件。用户空间是非特权区域，比如该区域执行的代码不能直接访问硬件设备
- 内核空间是操作系统所在区域，内核代码有特权，它能与设备控制器通讯，控制着用户区域进程的运行状态

### 虚拟内存

- 每个进程的内存空间只是虚拟内存空间，每次访问内存空间的某个地址都需要把地址翻译为实际物理内存地址
- 所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上
- 进程要知道哪些内存地址上的数据在物理内存上哪些不在，还有在物理内存上哪里？需要用页表来记录(页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录内存页的地址(如果存在的话))
- 当进程访问某个虚拟地址去看页表，如果发现对应的数据不在物理内存中则发生缺页异常，缺页异常的过程就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了没有空地方，那就找一个页覆盖。当然如果被覆盖的页曾经被修改过，需要将此页写会磁盘

### 内存映射文件

传统的文件`I/O`是通过用户进程发布`read( )`和`write( )`系统调用来传输数据的。为了在内核空间的文件系统页与用户空间的内存区之间移动数据，一次以上的拷贝操作几乎总是免不了的。这是因为在文件系统页与用户缓冲区之间往往没有一一对应关系。但是还有一种大多数操作系统都支持的特殊类型的`I/O`操作，允许用户进程最大限度地利用面向页的系统`I/O`特性，并完全摒弃缓冲区拷贝。这就是内存映射`I/O`

![用户内存到文件系统页的映射](https://raw.githubusercontent.com/RobertoHuang/RGP-LEARNING/master/NIO/images/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%A1%B5%E7%9A%84%E6%98%A0%E5%B0%84.png)

内存映射`I/O`使用文件系统建立从用户空间到可用文件系统页的虚拟内存映射，这样做有几个好处

- 用户进程把文件数据当做内存，所以无需发布`read()`或`write()`调用
- 当用户进程碰触到映射内存空间页错误会自动产生，从而将文件数据从磁盘读进内存
- 如果用户修改了映射内存空间相关页会自动标记为脏，随后刷新到磁盘文件得到更新
- 操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理
- 数据总是按页对齐的，无需执行缓冲区拷贝
- 大型文件使用映射无需消耗大量内存，即可进行数据拷贝

