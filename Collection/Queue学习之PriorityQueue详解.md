# PriorityQueue

> 参考:[死磕JAVA集合之PriorityQueue源码分析](https://github.com/alan-tang-tt/yuan/blob/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/16.%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E4%B9%8BPriorityQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)
>
> 优先级队列是0个或多个元素的集合，集合中的每个元素都有一个权重，每次出队都弹出优先级最大或最小值
>
> 优先级队列通常使用堆来实现，关于堆的详细介绍可参考:[数据结构之堆](https://github.com/alan-tang-tt/yuan/blob/master/%E6%AD%BB%E7%A3%95%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/13.%E6%AD%BB%E7%A3%95%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86.md)，以下是关于堆的总结
>
> - 堆是一颗完全二叉树
> - 小(大)顶堆中的每一个节点都不小于(不大于)它的父节点
> - 堆的插入、删除元素的时间复杂度都是`O(log n)`
> - 建堆的时间复杂度是`O(n)`
> - 堆排序的空间复杂度是`O(1)`
> - 堆排序的时间复杂度是`O(nlog n)` -> 依次删除堆顶元素进行排序得出

## 总结

- `PriorityQueue`不是线程安全的类

- `PriorityQueue`是一个小顶堆(越小优先级越高)
- 插入元素自下而上堆化(一直和父节点比较，如果比父节点小就与父节点交换位置)
- 删除元素自上而下堆化(一直往下与最小的子节点比较，如果比最小的子节点大就交换位置)
- 底层实现是一个数组，当数组长度小于64时每次容量翻倍，当数组长度大于64时每次扩容只增加一半的容量