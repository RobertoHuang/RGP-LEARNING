# 分代垃圾收集算法

- 为什么要分成年轻代和老年代

    大部分对象的生命周期很短，创建出来使用后需要立即回收

    少数对象的生命周期很长，需要长期停留在Java内存中，不会轻易被垃圾回收。这样我们可以根据不同场景选择不同垃圾回收算法进行优化

- 什么是永久代，永久带什么时候回被回收(等价于类什么时候会被卸载)

    永久代其实就是之前提到的方法区，可以认为永久代就是用来存放一些类的信息。满足以下条件后类会被卸载

    - 对该类的Class没有任何引用
    - 该类所有实例对象已经从JAVA堆内存中回收
    - 加载这个类的ClassLoader已经被回收

    **注意:由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中始终不会被卸载**

- 对象什么时候进入新生代，什么时候进入老年代

    - 大部分的正常对象都是优先在新生代分配内存的，大对象会直接分配到老年代

        【可以通过参数-XX:PretenureSizeThreshold来进行修改】

    - 如果一个新生代对象在15次Minor GC后还是没有被回收掉，会进入老年代

        【可以通过参数-XX:MaxTenuringThreshold来进行修改】

    - 动态对象年龄判定:虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，而是会根据各个年龄段的对象的和占用Survivor空间的比率，来判断哪些年龄的的对象可以晋升到老年代

        **设想:如果有很多对象的年龄都没达到MaxTenuringThreshold指定的阈值，这些对象就一直保留在Survivor区中，新对象进来可能就没办法移动到Survivor区，这些对象会进入老年代，老年代对象增多容易造成Full GC。这是个大问题**

        JVM会记录每个年龄段的对象的大小将每个年龄段的大小从小到大累加，如果该值超过了Suvivor容量的50%，就会取这个年龄和MaxTenuringThreshold两者中较小的那个值，从这个值往上的所有年龄段的对象晋升到老年代。比如:**(Suvivor区大小10M，年龄段1大小3M，年龄段2大小2M，年龄段3大小3M，年龄段4大小1M，TargetSurvivorRatio设置为50，MaxTenuringThreshold设置为15，则(年龄段1+年龄段2+年龄段3) > (10 * 50)/100，此时得到的年龄段是3，3和15比较取3，下次YGC时所有年龄段3和年龄段4的对象晋升到老年代)**

    - Minor GC后剩余的存活对象太多，没办法放入另外一块Survivor区域，这些对象也直接进入老年代

        空间分配担保:如果新生代区域有大量对象存活下来，确实是自己的Survivor区域放不下来必须放到老年代去，如果老年代空间也放不下这些对象应该怎么办？假如在Minor GC之前发现老年代区域已经小于新生代的全部对象大小，那么有可能在Minor GC之前发现老年代的可用内存已经小于新生代的全部对象大小，那么这个时候是不是可能在Minor GC之后新生代所有对象都存活下来，全部需要转移到老年代，然而老年代空间又不够用。这时候有两个判断:先判断参数-XX:HandlePromotionFailure参数是否设置，如果设置了则判断之前每一次Minor GC后进入老年代的平均大小是否小于老年代当前剩余空间。如果两者条件都满足则会冒险的进行一次Minor GC，但是只要有其中一个条件不满足就会先进行Full GC后再进行Minor GC

        - Minor GC之后剩余的存活对象是小于Survivor区存活对象进入Survivor
        - Minor GC之后剩余的存活对象大于Survivor区但是小于老年代剩余空间，直接进入老年代
        - Minor GC之后剩余对象大于Survivor区且大于老年代剩余空间大小【如果先决条件判断失败已经执行过一次Full GC则会触发OOM，如果之前是冒险Minor GC此时会发生一次Full GC，如果Full GC之后老年代还是没有足够空间存放则会触发OOM异常，因为内存实在是不够用了】

        **注意:老年代进行垃圾回收的时候同时也一般会对新生代进行垃圾回收**

