# Kafka

> 多分区、多副本且基于`Zookeeper`协调的分布式消息系统
>
> 分布式流处理平台。高吞吐，可持久化，可水平扩展，支持流数据处理等多种特性
>
> 参考资料:
>
> `Kafka`核心设计与实现 - 朱忠华
>
> `Apache Kafka`源码剖析 - 徐郡明

- `Offset`是消息在分区中的唯一标识，`Kafka`通过它来保证在分区内的顺序性

  不过`Offset`并不跨越分区，也就是说`Kafka`保证的是分区有序而不是主题有序

- 多分区:如果一个主题只对应一个分区，那么这个文件所在的机器`I/O`将会成为这个主题的瓶颈，而分区解决了这个问题。每一条消息被发送到`Broker`之前会根据分区规则选择存储到哪个具体分区(分区只能增不能删)

- `Kafka`为分区引入了多副本`Replica`机制，通过增加副本数量可以提升容灾能力。副本之前是一主多从的关系，其中`Leader`副本负责处理读写请求，`Follower`副本只负责与`Leader`副本的消息同步。当`Leader`副本出现故障时，从`Follower`副本中重新选举新的`Leader`来对外提供服务，保证某个`Broker`宕机服务任可用

- `Kafka`消费也具备一定容灾能力，`Consumer`使用`Pull`模式从服务端拉取消息并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费【保存在内部`Topic`】

## AR

分区中的所有副本统称为`AR`，`AR=ISR+OSR`

`OSR`与`Leader`副本同步滞后过多的副本(不包括`Leader`副本)组成`OSR`

`ISR`与`Leader`副本保存一定程度同步的副本(包括`Leader`副本在内)组成`ISR`

默认情况下当`Leader`副本发生故障时，只有在`ISR`集合中的副本才有资格被选举为新的`Leader`，而在`OSR`集合中的副本则没有任何机会(不过这个原则也可以通过修改相应的参数配置来改变)

## HW和LEO

`LEO`是`Log End Offset`的缩写，它标识当前日志文件中下一条待写入消息的`offset`，即`LEO`的大小相当于当前日志分区中最后一条消息的`offset`值加一，分区`ISR`集合中的每个副本都会维护自身的`LEO`，而`ISR`集合中最小的`LEO`即为分区的`HW`，对消费者而言只能消费`HW`之前的消息