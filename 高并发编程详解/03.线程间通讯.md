# 线程通信

## wait和notify

> 必须在同步方法中使用`wait`和`notify`方法，因为执行`wait`和`notify`的前提是必须持有同步方法`monitor`的所有权。线程在执行`wait`方法时会释放`monitor`的锁，当`wait`线程被唤醒后需要重新获取对象所关联的`monitor`的`lock`才能继续执行

- `wait和notify`实现生产者和消费者通讯

  ```java
  public class ProduceConsumerVersion {
      private int i = 0;
      final private Object LOCK = new Object();
      private volatile boolean isProduced = false;
  
      public void produce() {
          synchronized (LOCK) {
              if (isProduced) {
                  try {
                      LOCK.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              } else {
                  i++;
                  System.out.println("P->" + i);
                  LOCK.notify();
                  isProduced = true;
              }
          }
      }
  
      public void consume() {
          synchronized (LOCK) {
              if (isProduced) {
                  System.out.println("C->" + i);
                  LOCK.notify();
                  isProduced = false;
              } else {
                  try {
                      LOCK.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  
      public static void main(String[] args) {
          ProduceConsumerVersion pc = new ProduceConsumerVersion();
          Stream.of("P1").forEach(n ->
                  new Thread(n) {
                      @Override
                      public void run() {
                          while (true)
                              pc.produce();
                      }
                  }.start()
          );
  
          Stream.of("C1").forEach(n ->
                  new Thread(n) {
                      @Override
                      public void run() {
                          while (true)
                              pc.consume();
                      }
                  }.start()
          );
      }
  }
  ```

- 上述`Demo`在同时运行多个生产者和多个消费者的实例时会出现问题，改进版

  ```java
  public class ProduceConsumerVersion2 {
      private int i = 0;
      final private Object LOCK = new Object();
      private volatile boolean isProduced = false;
  
      public void produce() {
          synchronized (LOCK) {
              while (isProduced) {
                  try {
                      LOCK.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
              i++;
              System.out.println("P->" + i);
              LOCK.notifyAll();
              isProduced = true;
          }
      }
  
      public void consume() {
          synchronized (LOCK) {
              while (!isProduced) {
                  try {
                      LOCK.wait();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
              System.out.println("C->" + i);
              LOCK.notifyAll();
              isProduced = false;
          }
      }
  
      public static void main(String[] args) {
          ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();
          Stream.of("P1", "P2", "P3").forEach(n ->
                  new Thread(n) {
                      @Override
                      public void run() {
                          while (true) {
                              pc.produce();
                              try {
                                  Thread.sleep(10);
                              } catch (InterruptedException e) {
                                  e.printStackTrace();
                              }
                          }
                      }
                  }.start()
          );
          Stream.of("C1", "C2", "C3", "C4").forEach(n ->
                  new Thread(n) {
                      @Override
                      public void run() {
                          while (true) {
                              pc.consume();
                              try {
                                  Thread.sleep(10);
                              } catch (InterruptedException e) {
                                  e.printStackTrace();
                              }
                          }
                      }
                  }.start()
          );
      }
  }
  ```

  > 改进考虑的点:
  >
  > 
  >
  > 由于莫名其妙的原因线程有可能在没有调用过`notify()`和`notifyAll()`的情况下醒来，这就是所谓的虚假唤醒。为了防止假唤醒保存信号的成员变量将在一个`while`循环里接受检查而不是在`if`表达式里，这样的一个`while`循环叫做自旋锁【`while(条件不满足){ this.wait();} `】
  >
  > 
  >
  > 在虚拟机规范中存在一个`wait set`的概念，当线程调用了某个对象`wait`方法之后都会被加入与该对象`monitor`关联的`wait set`中，并且释放`monitor`的所有权。当若干个线程调用了`wait`方法之后被加入与`monitor`关联的`wait set`中，待另一个线程调用该`monitor`的`notify`方法之后，其中一个线程会从`wait set`中弹出，至于是随机还是以`FIFO`方式弹出虚拟机规范没有给出强制要求。而执行`notifyAll`则是将`wait set`中所有线程弹出

- 使用`wait notify`实现简单的锁(改进`synchronized`不可响应中断、不能设置超时时间问题)

  ```java
  public interface Lock {
      class TimeOutException extends Exception {
          public TimeOutException(String message) {
              super(message);
          }
      }
  
      void lock() throws InterruptedException;
  
      void lock(long mills) throws InterruptedException, TimeOutException;
  
      void unlock();
  }
  ```

  ```java
  public class BooleanLock implements Lock {
      private boolean initValue;
      private Thread currentThread;
      private Collection<Thread> blockedThreadCollection = new ArrayList<>();
  
      public BooleanLock() {
          this.initValue = false;
      }
  
      @Override
      public synchronized void lock() throws InterruptedException {
          while (initValue && currentThread != Thread.currentThread()) {
              blockedThreadCollection.add(Thread.currentThread());
              this.wait();
          }
          this.initValue = true;
          this.currentThread = Thread.currentThread();
          blockedThreadCollection.remove(Thread.currentThread());
      }
  
      @Override
      public synchronized void lock(long mills) throws InterruptedException, TimeOutException {
          if (mills <= 0)
              lock();
          long hasRemaining = mills;
          long endTime = System.currentTimeMillis() + mills;
          while (initValue && currentThread != Thread.currentThread()) {
              if (hasRemaining <= 0)
                  throw new TimeOutException("Time out");
              blockedThreadCollection.add(Thread.currentThread());
              this.wait(mills);
              hasRemaining = endTime - System.currentTimeMillis();
          }
          this.initValue = true;
          this.currentThread = Thread.currentThread();
          blockedThreadCollection.remove(Thread.currentThread());
      }
  
      @Override
      public synchronized void unlock() {
          if (Thread.currentThread() == currentThread) {
              this.initValue = false;
              Optional.of(Thread.currentThread().getName() + " release the lock monitor.").ifPresent(System.out::println);
              this.notifyAll();
          }
      }
  }
  ```

  
