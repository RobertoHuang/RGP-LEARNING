# 虚拟机

## 常用参数

`-Xms:Java堆内存大小`

`-Xmx:Java堆内存最大大小`

`-Xmn:Java堆中年轻代大小，扣除新生代大小剩下的就是老年代大小`

`-XX:PermSize:Java永久代大小` `JDK8之后修改为:-XX:MetaspaceSize`

`-XX:MaxPermSize:Java永久代最大值` `JDK8之后修改为:-XX:MaxMetaspaceSize`

`-Xss:每个线程栈的大小`

所谓`JVM`优化就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。要避免`FullGC`可以从这几点考虑

- 增大年轻代对象年龄
- 修改新生代老年代的占比
- 修改新生代`Eden`区和`Survivor`区的比例

垃圾收集器优化的最终目标是:尽可能减少`Stop the world`时间并且增加垃圾回收的数量

## 内存区域划分

- 程序计数器:记录当前线程所执行的字节码的行号指示器，为了线程切换后能正确恢复到正确的执行位置，每个线程都需要独立的程序计数器，各个线程之前计数器互不影响，我们称这类内存区域为线程私有内存
- 虚拟机栈:`Java`虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是`Java`方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程就对应一个栈帧在虚拟机栈中入栈和出栈的过程
- 本地方法栈:本地方法栈与虚拟机栈发挥的作用是非常相似的，他们之前的区别只不过是虚拟机栈为虚拟机执行`Java`方法服务，而本地方法栈为虚拟机使用到的`Native`方法服务
- 堆:此内存区域的唯一目的就是存放对象实例
- 方法区:用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

## 类加载

- `JVM`在什么情况下会加载一个类

    一个类从加载到使用一般会经历这么几个阶段【加载 -> 连接 -> 初始化 -> 使用 -> 卸载】

    连接阶段分为【验证 -> 准备 -> 解析】，其中验证阶段就是验证加载进来的`.class`文件中的内容是否符合虚拟机规范，准备阶段是为类变量分配内存并设置类变量的初始值，解析阶段是将符号引用转为直接应用的过程

    当一个类被主动调用的时候会触发类的加载，类的主动调用有以下场景

## 分代算法

- 为什么要分成年轻代和老年代

    大部分对象的生命周期很短，创建出来使用后需要立即回收、少数对象的生命周期很长，需要长期停留在`Java`内存中，不会轻易被垃圾回收。这样我们可以根据不同场景选择不同垃圾回收算法进行优化

- 什么是永久代，永久带什么时候回被回收(等价于类什么时候会被卸载)

    永久代其实就是之前提到的方法区，可以认为永久代就是用来存放一些类的信息。满足一下条件后类会被卸载

    - 对该类的`Class`没有任何引用
    - 该类所有实例对象已经从`JAVA`堆内存中回收
    - 加载这个类的`ClassLoader`已经被回收

- 对象什么时候进入新生代，什么时候进入老年代

    - 大部分的正常对象都是优先在新生代分配内存的，大对象会直接分配到老年代

        【可以通过参数`-XX:PretenureSizeThreshold`来进行修改】

    - 如果一个新生代对象在15次`Minor GC`后还是没有被回收掉，会进入老年代

        【可以通过参数`-XX:MaxTenuringThreshold`来进行修改】

    - 动态对象年龄判定:虚拟机并不是永远地要求对象的年龄必须达到了`MaxTenuringThreshold`才能晋升到老年代，如果在`Survivor`空间中相同年龄的所有对象大小的总和大于`Survivor`空间的一半，年龄大于或等于年龄的对象就可以直接进入老年代，无须等`MaxTenuringThreshold`中要求的年龄。无论是15岁的年龄判定还是动态年龄判断的规则，都是希望那些可能是长期存活的对象，尽早进入老年代

    - `Minor GC`后剩余的存活对象太多，没办法放入另外一块`Survivor`区域，这些对象也直接进入老年代

        空间分配担保:如果新生代区域有大量对象存活下来，确实是自己的`Survivor`区域放不下来必须放到老年代去，如果老年代空间也放不下这些对象应该怎么办？假如在`Minor GC`之前发现老年代区域已经小于新生代的全部对象大小，那么有可能在`Minor GC`之前发现老年代的可用内存已经小于新生代的全部对象大小，那么这个时候是不是可能在`Minor GC`之后新生代所有对象都存活下来，全部需要转移到老年代，然而老年代空间又不够用。这时候有两个判断:先判断参数`-XX:HandlePromotionFailure`参数是否设置，如果设置了则判断之前每一次`Minor GC`后进入老年代的平均大小是否小于老年代当前剩余空间。如果两者条件都满足则会冒险的进行一次`Minor GC`，但是只要有其中一个条件不满足就会先进行`Full GC`后再进行`Minor GC`。在进行前置操作后执行`Minor GC`有如下几种情况

        - `Minor GC`之后剩余的存活对象是小于`Survivor`区存活对象进入`Survivor`
        - `Minor GC`之后剩余的存活对象大于`Survivor`区但是小于老年代剩余空间，直接进入老年代
        - `Minor GC`之后剩余对象大于`Survivor`区且大于老年代剩余空间大小【如果先决条件判断失败已经执行过一次`Full GC`则会触发`OOM`，如果之前是冒险`Minor GC`此时会发生一次`Full GC`，如果`Full GC`之后老年代还是没有足够空间存放则会触发`OOM`异常，因为内存实在是不够用了】

        **所以可以得出结论老年代发生`GC`时机一般有两个**

        - 在`Minor GC`之前发现可能`Minor GC`之后要进入老年代的对象太多了，老年代放不下
        - 在`Minor GC`之后剩余的【达到上诉进入老年代条件】存活对象太多了，老年代放不下
        - 如果老年代使用的`CMS`垃圾收集器默认在老年代使用达到92%的时候会触发`Full GC`
        
        **注意:老年代进行垃圾回收的时候同时也一般会对新生代进行垃圾回收**

- 什么时候会触发`YoungGC`

    当分配新对象时，发现新生代内存空间不足就会触发`YoungGC`回收掉大量垃圾对象
    
    `G1`垃圾收集器发现新生代垃圾对象回收所需时间达到`-XX:MaxGCPausemills`配置的值

## 怎么合理的设置JVM参数

首先要对系统压力进行估算，从而对`JVM`压力有个大概的估算值才能合理的设置`JVM`参数

比如日交易订单达到百万的一个支付系统，那每秒的请求数量就是大概就是15个这样

每个请求数量涉及到的对象大小总和会是多少，可以估算出每秒大概需要耗费多少内存空间

还得判断每个请求的处理时长，比如说是1S那就以为着这15KB的数据在1S内就必须常驻在内存(这个可以结合`Minor GC`发生频率，对要调整的`JVM`参数进行优化)，防止过多对象进入老年代

通常我们的估算都要保守一点，可以加点偏移量，比如每个请求每个请求需开辟1KB的内存，那每秒实际大概是占用15KB，我们可以*20的偏移量那每秒就大概需要开辟300KB的内存。基于这个数据再去合理的设置`JVM`参数

## 哪些被引用对象不能被回收

- 引用计数法

    两个类互相引用则都不能被回收

- 可达性分析法 `GC ROOT`

    有`GC ROOTS`引用的对象不能被回收，没有`GC ROOTS`引用的对象可以被回收

    如果是软弱引用也可能被回收
    
    对象被回收前会回调对应的`finalize()`方法，如果这里让某个`GC ROOTS`引用自己则该对象不会被回收
    
    以下这些可以作为`GC ROOTS`
    
    - 虚拟机栈(栈桢中的本地变量表)中的引用的对象
    - 本地方法栈中`JNI`的引用的对象
    - 方法区中的类静态属性引用的对象及方法区中常量引用的对象

## 四种引用类型

强引用:垃圾回收的时候不会回收这类型的对象

软引用:垃圾回收之后发现内存空间还是不够存放新对象，则回回收软引用

弱引用:弱引用就和没引用有点类似，垃圾回收的时候可能就会把这个对象回收掉

虚引用用的比较少【】

## 垃圾回收算法

标记出哪些对象是可以被回收的，然后直接对那块内存区域进行回收把内存空出来 - 造成大量内存碎片

【标记清除算法】

内存碎片太多的时候，所有的内存碎片加起来其实有很大一块区域，但是因为这些内存都是碎片分散的，所以导致没有一块连续的足够的内存空间来分配新的对象。造成大量内存浪费

【复制算法】

把内存分成两块，然后只使用其中一块，待那块内存快满的时候就把里面存活的对象移动到另外一个区域，保证没有内存碎片。接着再一次性回收原来的那块内存区域，两块内存就这样循环使用【内存利用率太低】

【分代算法】

年轻代使用复制算法的优化:我们的代码不停的创建对象然后分配在新生代里，但是一般很快就没人引用这个对象了，成了垃圾对象，接着一段时间过后新生代满了，此时就会回收掉那些垃圾对象，空出内存空间给或许新对象使用。但是之前我们分析过绝大多数对象存活的周期非常的短，可能创建一毫秒之后就没人引用它了，所以可能经过一次垃圾回收算法后，有99%的对象都被回收了，就1%的对象存活下来。可能就是一些长期对象或者还没使用完的对象。所以需要重写定义复制算法。【一个`Eden`两个`Survivor`区，默认比例8：1：1】- 内存使用率高达90%

**可以通过`XX:SurvivorRatio`参数来调整`Eden`区域和`Survivor`区的比例**

老年代使用标记整理算法【因为老年代发生`GC`后存活的对象可能还很多，如果使用复制算法不太合适】，把存活的对象都挪到一边去紧凑的靠在一起。避免垃圾回收后出现过多的碎片

## 常见垃圾收集器

【Serial和Serial Old垃圾收集器】

分别用来回收年轻代和老年代的垃圾对象， 工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让它们执行垃圾回收

【ParNew和CMS垃圾收集器**一般是线上生产系统的标配组合**】

`ParNew`一般是用在新生代的垃圾收集器，`CMS`是用在老年代的垃圾收集器

他们都是多线程并发机制，性能更好，一般是线上生产系统的标配组合

启用`ParNew`垃圾收集器【`-XX:UseParnewGC`】,默认情况下线程数和`CPU`核数相等

可以使用参数`-XX:ParallelGCThreads`进行修改，但是一般不建议这么做

`Serial`和`ParNew`如果进行选择:大部分情况下服务端应用选择`ParNew`客户端应用选择使用`Serial`，这关键取决于机器的核心数量。因为客户端程序大部分是单核`CPU`，如果使用多线程反而因为线程上下文切换增加开销

启用`CMS`垃圾收集器【`-XX:+UseConcMarkSweepGC`】，假设先`Stop the word`再去执行垃圾回收算法会导致系统卡顿时间过长，很多请求无法被正确处理。所以`CMS`垃圾回收器采用的是垃圾回收线程和系统工作线程同时执行的模式来处理的。它经历如下四个阶段【初始标记 > 并发标记 > 重新标记 > 并发清理】

- 初始标记:标记直接被`GC Root`引用或被年轻代存活对象引用的所有对象【`stop the world`但运行速度很快】
- 并发标记:根据上个阶段找到被`GC Root`引用的存活对象遍历查找【并发运行】
- 重新标记阶段:对在阶段二中被系统运行修改过的对象进行标记【`stop the world`但运行速度很快】
- 并发清理:让程序随意运行，清理掉之前标记为垃圾的对象【并发运行】

`CMS`垃圾收集器的缺点

- `CMS`收集器对`CPU`资源非常敏感。在并发阶段它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低【`-XX:ParallelGCThread`】

- `CMS`是基于标记-清除算法的，`CMS`只会删除无用对象，不会对内存做压缩会造成内存碎片。当空间碎片过多将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次`Full GC`【`XX:CMSFullGCsBeforeCompaction=10`】
- `concurrent mode failure`由于`CMS`并发标记和并发清理阶段是和业务线程同时运行的，所以当年轻带空间满了执行`Minor GC`时需要将存活的对象放入到老年代，而此时老年代空间不足，这时`CMS`还没有机会回收老年带产生的，或者在做`Minor GC`的时候，新生代`Survivor`区放不下，需要放入老年代，而老年代也放不下而产生的【`-XX:CMSInitiatingOccupancyFraction=70`和`-XX:+UseCMSInitiatingOccupancyOnly`】。当发生`concurrent mode failure`，此时就会导致立马进入`Stop the World`然后切换`CMS`为`Serial Old`直接禁止程序运行，然后单线程进行老年代垃圾回收再让系统继续运行

【G1垃圾收集器】

启用`G1`垃圾收集器【`-XX:UseG1GC`】

`G1`统一收集新生代和老年代，采用了更加优秀的算法和设计原则。他最大的一个特点，就是把`Java`堆内存拆分为多个大小相等的`Region`。并且让我们设置一个垃圾回收的预期停顿时间【`-XX:MaxGCPausemills`】

- `G1`是如何做到对垃圾回收导致的系统停顿可控的

    其实`G1`如果要做到这一点，他就必须要追踪每个`Region`里的回收价值，啥叫做回收价值呢？它必须搞清楚每个`Region`里的对象有多少是垃圾，如果对这个`Region`进行垃圾回收需要耗费多长时间，可以回收掉多少垃圾

    所以简单来说`G1`可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小`Region`，以及追踪每个`Region`中可以回收的对象大小和预估时间，最后在垃圾回收的时候尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时 间内尽量回收尽可能多的垃圾对象

- `Region`可能属于新生代也可能属于老年代

    在`G1`对应的内存模型中`Region`随时会属于新生代也会属于老年代，所以没有所谓新生代给多少内存，老年代给多少内存这一说了。实际上新生代和老年代各自的内存区域是不停的变动的，由`G1`自动控制

    刚开始的时候默认新生代对堆内存的占比是5%，这个是可以通过`-XX:G1NewSizePercent`来设置新生代初始占比，其实维持这个默认值即可。因为在系统运行中`JVM`其实会不停的给新生代增加更多的`Region`，但是最多新生代的占比不会超过60%，可以通过`- XX:G1MaxNewSizePercent`参数进行设置。而且一旦`Region`进行了垃圾回收，此时新生代的`Region`数量还会减少，但是这些其实都是动态的

- 到底有多少个`Region`呢？每个`Region`的大小是多大呢

    我们可以给整个堆内存设置一个大小，比如说用`-Xms`和`-Xmx`来设置堆内存的大小。然后`JVM`启动的时候一旦发现你使用的是`G1`垃圾回收器，此时会自动用堆大小除以`2048`。因为`JVM`最多可以有2048个`Region`

    `Region`的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。比如说堆大小是4G，那么就是4096MB，此时除以2048个`Region`，每个`Region`的大小就是2MB。大概就是这样子来决定`Region`的数量和大小的，大家一般保持默认的计算方式就可以。如果需要手动指定可通过参数【`-XX:G1HeapRegionSize`】

- 新生代还有`Eden`和`Survivor`的概念吗

    在`G1`中虽然把内存划分为了很多的`Region`，但是其实还是有新生代、老年代的区分。而且新生代里还是有`Eden`和`Survivor`的划分的。同样通过参数【`-XX:SurvivorRatio=8`】指定。只不过随着对象不停的在新生代里分配，属于新生代的`Region`会不断增加，`Eden`和`Survivor`对应的`Region`也会不断增加

- 新生代垃圾回收

    随着不停的在新生代的`Eden`对应的`Region`中放对象，`JVM`就会不停的给新生代加入更多的`Region`，直到新生代占据堆大小的最大比例(默认值60%)就会触发`Minor GC`。`G1`是通过复制算法来回收的

- 大对象`Region`

    `G1`提供了专门的`Region`来存放大对象，而不是让大对象进入老年代的`Region`中。在`G1`中大对象的判定规则就是一个大对象超过了一个`Region`大小的50%，比如每个`Region`是2MB，只要一个大对 象超过了1MB就会被放入大对象专门的`Region`中，而且一个大对象如果太大，可能会横跨多个`Region`来存放

- 堆内存里哪些`Region`用来存放大对象啊?
    不是说60%的给新生代，40%的给老年代吗，那还有哪些`Region`给大对象？

    在`G1`里新生代和老年代的`Region`是不停的变化的，比如新生代现在占据了1200个`Region`，但是一次垃圾回收之后，就让里面1000个`Region`都空了，此时那1000个`Region`就可以不属于新生代了，里面很多`Region`可以用来存放大对象

- 大对象既然不属于新生代和老年代，那么什么时候会触发垃圾回收呢？

    其实新生代、老年代在回收的时候，会顺带带着大对象`Region`一起回收

    所以这就是在`G1`内存模型下对大对象的分配和回收的策略

`Parnew`和`CMS`带来的痛点是:无论新生代还是老年代的垃圾回收或多或少产生`stop the world`

而`G1`可以设置一个垃圾回收最大停顿时间 ，它根据预期系统时间来选择最少回收时间和最多回收对象的`Region`进行垃圾回收，保证在`GC`对系统停顿的影响在可控时间范围内同时尽可能回收最多对象

`Minor GC`的触发时机和参数`-XX:MaxGCPausemills`也是紧密相关的

它把`Java`堆内存拆分成多个`Region`，`Region`可能属于新生代也可能属于老年代

新生代仍然有`Eden`和`Survivor`的概念，并且还是通过`-XX:SurvivorRatio`属性配置`Eden`区域和`Survivor`占比可以通过属性`-XX:G1NewSizePercent`设置新生代初始化大小、`-XX:G1MaxNewSizePercent`新生代最大大小

`G1`垃圾收集器进入老年代的条件和之前描述的一致，但是`G1`对大对象使用专门的`Region`来管理，如果一个对象超过`Region`大小的50%则被认为是大对象，就会被放入专门的大对象`Region`，如果对象太大会横跨多个`Region`

当老年代超过45%的`Region`的时候会触发混合回收，回收对象包括老年代、新生代、大对象，`G1`回收过程和`CMS`有点类似，不过`G1`最后使用的是复制算法进行`Region`回收所以不会出现内存碎片

混合回收相关的参数

`-XX:G1MixedGCCountTarget`在一次混合回收中最后一个阶段执行几次内存回收

`-XX:G1HeapWastePercent`当空闲`Region`达到总的`Region`百分多少时，停止混合回收

## Stop the world

因为在垃圾回收的时候要尽可能的让垃圾回收器专心致志的工作，不能让我们写的`Java`系统继续再创建对象了，所以此时我们的后台进入`Stop the world`状态，也就是它会停止我们所有的工作线程，让我们代码不再允许。接着一旦垃圾回收完毕，就可以继续恢复我们写的`Java`系统的工作线程。

## 附录

新生代如果太小，系统压力大的时候会导致请求处理比较慢。导致部分对象在`Minor GC`后一直没办法没回收，导致一直有对象进入老年代。老年代对象不断增大导致触发`Full GC`，引发系统卡顿